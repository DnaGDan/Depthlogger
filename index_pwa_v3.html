<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Brownfield Solutions Depth-to-Water Logger PWA - v3.1 - High Contrast</title>
  <link rel="manifest" href="./manifest.json" />
  <link rel="apple-touch-icon" href="./icon-192.png" />
  <meta name="theme-color" content="#0b3ea2" />

  <!-- High-contrast refresh; plus robust JS (fixed malformed fragments) -->

  <style>
    /* ---------- Design tokens ---------- */
    :root {
      /* Dark (default) */
      --bg: #0b1020;
      --fg: #eef4ff;
      --muted: #a8b3cf;
      --card: #121a33;
      --border: #2a3a66;
      --accent: #0b66c2; /* darker blue for > 4.5 contrast on white/near-white */
      --accent-contrast: #ffffff;
      --danger: #b91c1c;
      --success: #0f766e;
      --warning: #a16207;

      --btn-bg: var(--accent);
      --btn-fg: var(--accent-contrast);
      --btn-bg-hover: #084f98;
      --btn-border: transparent;

      --input-bg: #0f1530;
      --input-fg: var(--fg);
      --input-border: #3a4a7a;
      --input-placeholder: #7b88a8;
      --focus-ring: #7aa9f6;

      --table-head-bg: #182245;
      --table-row-odd: #121a33;
      --table-row-even: #0f1730;

      --link: #8ab4ff;
      --shadow: 0 6px 18px rgba(0, 0, 0, 0.35);
    }

    .theme-light {
      --bg: #ffffff;
      --fg: #101423;
      --muted: #4b5568;
      --card: #f8fafc;
      --border: #d3d9e4;
      --accent: #0b3ea2; /* dark enough on white */
      --accent-contrast: #ffffff;

      --btn-bg: var(--accent);
      --btn-fg: var(--accent-contrast);
      --btn-bg-hover: #082f7a;
      --btn-border: transparent;

      --input-bg: #ffffff;
      --input-fg: var(--fg);
      --input-border: #9aa7bd;
      --input-placeholder: #6b7280;
      --focus-ring: #0b66c2;

      --table-head-bg: #e6eefc;
      --table-row-odd: #ffffff;
      --table-row-even: #f2f6ff;

      --link: #0b66c2;
      --shadow: 0 8px 20px rgba(16, 20, 35, 0.08);
    }

    /* ---------- Base reset ---------- */
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      padding: 16px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: var(--bg);
      color: var(--fg);
      line-height: 1.4;
    }

    img { max-width: 100%; height: auto; }

    a { color: var(--link); text-decoration: none; }
    a:hover { text-decoration: underline; }

    /* Card sections */
    .section {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 14px;
      margin: 14px 0;
      box-shadow: var(--shadow);
    }

    /* ---------- Header ---------- */
    #logo { max-width: 160px; display: block; margin: 8px auto 12px; }
    h1 {
      margin: 4px 0 8px;
      text-align: center;
      font-size: clamp(18px, 2.4vw, 24px);
      font-weight: 700;
      letter-spacing: 0.01em;
      color: var(--fg);
    }

    /* Compact top bar: logo + title + version + theme icon */
    .topbar {
      display: flex;
      align-items: center;
      gap: 12px;
      justify-content: space-between;
      margin-bottom: 12px;
    }
    .topbar img {
      max-width: 120px;
      height: auto;
    }
    .topbar h1 {
      margin: 0;
      font-size: clamp(18px, 2.2vw, 22px);
    }
    .topbar .meta {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 4px;
    }

    /* Theme toggle row */
    .row { display: flex; align-items: center; gap: 8px; }
    .row label { display: inline-flex; gap: 8px; align-items: center; cursor: pointer; }

    /* ---------- Buttons ---------- */
    button {
      appearance: none;
      border: 1px solid var(--btn-border);
      background: var(--btn-bg);
      color: var(--btn-fg);
      padding: 10px 14px;
      border-radius: 10px;
      font-weight: 600;
      transition: transform 0.06s ease, background 0.15s ease, box-shadow 0.15s ease;
      box-shadow: 0 1px 0 rgba(0,0,0,0.12);
    }
    button:hover { background: var(--btn-bg-hover); }
    button:active { transform: translateY(1px); }
    button:focus-visible {
      outline: 3px solid var(--focus-ring);
      outline-offset: 2px;
    }

    /* High-contrast disabled: keep legible text */
    button:disabled,
    .btn[disabled] {
      background: #94a3b8; /* slate-400 */
      color: #0b1020;      /* very dark text for contrast */
      border-color: #64748b;
      cursor: not-allowed;
      filter: none;
      opacity: 1;
    }

    /* Secondary, ghost & danger styles for semantic clarity */
    .btn-ghost {
      background: transparent;
      border-color: var(--border);
      color: var(--fg);
    }
    .btn-ghost:hover { background: rgba(127, 146, 190, 0.14); }
    .btn-danger { background: var(--danger); }
    .btn-danger:hover { background: #991b1b; }

    /* ---------- Inputs ---------- */
    input, select, textarea {
      width: 100%;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid var(--input-border);
      background: var(--input-bg);
      color: var(--input-fg);
      outline: none;
      font-size: 16px;
    }
    input::placeholder, textarea::placeholder { color: var(--input-placeholder); }
    input:focus, select:focus, textarea:focus {
      border-color: var(--focus-ring);
      box-shadow: 0 0 0 3px color-mix(in srgb, var(--focus-ring) 25%, transparent);
    }
    input:disabled, textarea:disabled, select:disabled {
      background: color-mix(in srgb, var(--input-bg) 70%, #888 30%);
      color: color-mix(in srgb, var(--input-fg) 80%, #000 20%);
    }

    label { font-weight: 600; color: var(--fg); }

    /* ---------- Timer / Clock ---------- */
    #timer {
      font-size: clamp(28px, 7.5vw, 56px); /* large and legible */
      font-weight: 800;
      letter-spacing: 0.02em;
      text-align: center;
    }

    /* ---------- Table ---------- */
    table { width: 100%; border-collapse: separate; border-spacing: 0; }
    th, td { padding: 10px 12px; text-align: left; border-bottom: 1px solid var(--border); }
    thead th {
      background: var(--table-head-bg);
      position: sticky;
      top: 0;
      z-index: 2;
    }
    tbody tr:nth-child(odd) { background: var(--table-row-odd); }
    tbody tr:nth-child(even) { background: var(--table-row-even); }

    /* ---------- Parameters panel (off-canvas) ---------- */
    #parameters {
      position: fixed;
      top: 0;
      right: 0;
      width: min(360px, 92vw);
      height: 100%;
      background: var(--card);
      border-left: 1px solid var(--border);
      padding: 16px;
      transform: translateX(110%); /* fully off-screen by default */
      transition: transform 0.28s ease;
      z-index: 1000;
      overflow-y: auto;
      box-shadow: var(--shadow);
    }
    #parameters.open { transform: translateX(0); }

    #parametersToggle {
      position: relative;
      z-index: 1001;
    }
    /* Hide the floating toggle while the panel is open to avoid overlap */
    .panel-open #parametersToggle { display: none; }

    /* Left sessions panel styles */
    #sessions { transform: translateX(-110%); } /* initial off-canvas */
    #sessions.open { transform: translateX(0); }
    /* When sessions panel is open hide its toggle to avoid duplicate controls */
    .sessions-open #sessionsToggle { display: none; }
    /* ensure the small tabs summary doesn't expand layout */
    #tabsSummary { max-width: 40vw; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }

    /* Microcopy */
    .hint { margin: 6px 0 0; font-size: 0.925rem; color: var(--muted); }
  </style>

  <!-- Keep the existing theme variables hook for JS toggling -->
  <style>
    #clock, #clockDisplay, .clock-display {
      font-size: clamp(24px, 6vw, 48px);
      font-weight: 700;
      letter-spacing: 0.02em;
    }
    .params-panel { transition: transform .3s ease, opacity .2s ease; will-change: transform, opacity; }
    .params-closed { transform: translateX(-120%); opacity: 0; pointer-events: none; visibility: hidden; }
    #micButton.listening, .mic-button.listening { position: relative; box-shadow: 0 0 0 4px rgba(255,0,0,.15); }
    #micButton.listening::after, .mic-button.listening::after { content: ""; position: absolute; right: -6px; top: -6px; width: 10px; height: 10px; border-radius: 50%; background: #e11; animation: pulse 1s infinite; }
    @keyframes pulse { 0%{transform:scale(.8); opacity:.6} 50%{transform:scale(1); opacity:1} 100%{transform:scale(.8); opacity:.6} }
  </style>

  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
</head>
<body>
  <!-- Compact top bar: logo + title + version + theme icon -->
  <header class="topbar" style="display:flex; align-items:center; gap:12px; justify-content:space-between; margin-bottom:12px;">
    <div style="display:flex; align-items:center; gap:12px;">
      <img id="logo" src="./brownfield_logo.png" alt="Brownfield Solutions Logo" />
      <div style="line-height:1;">
        <h1 style="margin:0; font-size: clamp(18px, 2.2vw, 22px);">Soakaway Logger</h1>
        <div class="meta" style="display:flex; align-items:center; gap:8px; margin-top:4px;">
          <!-- version & install status moved to app base -->
        </div>
      </div>
    </div>
    <div style="display:flex; align-items:center; gap:8px;">
      <!-- Put Test Parameters button in header (shows cog + text) -->
      <button id="parametersToggle" class="btn-ghost" title="Test Parameters" aria-label="Open Test Parameters">‚öôÔ∏è <span class="btn-label">Test Parameters</span></button>
    </div>
  </header>

  <!-- Tabs bar for multiple concurrent tests -->
  <div id="tabsBar" class="tabs" style="margin-bottom:10px; display:flex; align-items:center; justify-content:space-between; gap:8px;">
    <div style="display:flex; align-items:center; gap:8px;">
      <!-- small placeholder, full list moved to slide-out panel -->
      <div id="tabsSummary" style="font-weight:600; color:var(--muted)"></div>
    </div>
    <div style="display:flex; align-items:center; gap:8px;">
      <!-- Sessions panel toggle (opens left slide-out) -->
      <button id="sessionsToggle" class="btn-ghost" title="Sessions" aria-label="Open sessions">Sessions</button>
      <!-- keep theme toggle on the tabs line to reduce vertical space -->
      <button id="themeToggle" class="theme-toggle icon-only" aria-pressed="false" title="Toggle light / dark theme" aria-label="Toggle theme">üåô</button>
    </div>
  </div>

  <!-- Left slide-out panel for Sessions (tests tabs) -->
  <div id="sessions" class="section" aria-hidden="true" style="position:fixed; top:0; left:0; width:min(360px,92vw); height:100%; transition:transform .28s ease; z-index:1000; box-shadow:var(--shadow); border-right:1px solid var(--border); overflow:auto; background:var(--card); padding:16px;">
    <div class="row" style="justify-content:flex-start; gap:8px;">
      <button id="sessionsClose" class="btn-ghost" aria-label="Close sessions">Close</button>
      <h2 style="margin:0;">Sessions</h2>
      <div style="flex:1"></div>
    </div>
    <p class="muted" style="margin-top:6px;">Manage running tests. Click a session to activate it.</p>
    <div style="margin-top:8px;">
      <button id="newTestBtn" class="btn-ghost" title="Create new test">Ôºã New Test</button>
    </div>
    <ul id="sessionsList" style="margin-top:10px; list-style:none; padding:0;"></ul>
  </div>

  <div class="section" id="parameters">
    <div class="row" style="justify-content: space-between; gap: 8px;">
      <h2 style="margin: 0;">Test Parameters</h2>
      <button id="parametersClose" class="btn-ghost">Close</button>
    </div>
    <p class="muted" style="margin-top: 6px;">All dimensions in millimetres (mm). Bottom mirrors Top until edited.</p>

    <div class="stack" style="margin-top: 10px;">
      <div class="grid-2">
        <label>Location ID <input type="text" id="locationId" placeholder="e.g., TP03" /></label>
        <label>Test Number <input type="text" id="testNumber" placeholder="e.g., Test 1" /></label>
      </div>
      <div class="grid-2">
        <label>Length at Top <input type="number" id="lengthTop" placeholder="e.g., 2000" /></label>
        <label>Length at Bottom <input type="number" id="lengthBottom" placeholder="Mirrors top" /></label>
      </div>
      <div class="grid-2">
        <label>Width at Top <input type="number" id="widthTop" placeholder="e.g., 600" /></label>
        <label>Width at Bottom <input type="number" id="widthBottom" placeholder="Mirrors top" /></label>
      </div>
      <div class="grid-2">
        <label>Depth Tested (Head of Water)
          <input type="number" id="depthTested" readonly placeholder="Calculated" />
        </label>
        <label>Depth of Excavation
          <input type="number" id="depthExcavation" placeholder="e.g., 2000" />
        </label>
      </div>
      <div>
        <label>Void Ratio</label>
        <div class="grid-2">
          <select id="voidRatio">
            <option value="1">Open (1)</option>
            <option value="0.3">Single size stone (0.3)</option>
            <option value="">Other</option>
          </select>
          <input type="number" id="voidRatioOther" placeholder="Custom value" style="display: none;" />
        </div>
      </div>
      <div class="grid-2">
        <label>Strata Description <textarea id="strataDescription" placeholder="Sand over clay..."></textarea></label>
        <label>Pit Details <textarea id="pitDetails" placeholder="Benched sides, shored, etc."></textarea></label>
      </div>
      <p class="hint">Typical pit ‚âà 2000 √ó 600 √ó 2000 mm.</p>
    </div>
  </div>

  <div class="section" id="timerSection">
    <div id="timer">00:00:00</div>
    <div class="row" style="flex-wrap: wrap; gap: 8px; margin-top: 10px;">
      <button id="startPauseBtn" disabled>Start</button>
      <button id="stopTimer" disabled class="btn-danger">Stop</button>
      <button id="clearCurrent" class="btn-ghost">Clear Current Test</button>
    </div>
    <p class="hint">Timer rounds to the nearest second. Times are exported as decimal minutes (2 dp).</p>
  </div>

  <div class="section" id="recordSection">
    <div class="grid-2">
      <label>Depth to Water (mm) <input type="number" id="depthInput" placeholder="Enter depth" /></label>
      <div id="depthError" style="display:none; color:var(--danger); margin-top:6px; font-weight:700;">Depth cannot be greater than excavation depth. Please re-measure.</div>
      <div class="stack">
        <span class="muted">Voice input (Chrome):</span>
        <button id="speechButton" title="Use speech recognition">üé§ Speak depth</button>
      </div>
    </div>
    <div class="row" style="gap: 16px; margin-top: 8px;">
      <span>25% fall: <strong id="fall25">‚Äî</strong> mm</span>
      <span>75% fall: <strong id="fall75">‚Äî</strong> mm</span>
    </div>
    <p class="hint">Press Enter inside the field to record instantly.</p>

    <!-- Quartile Progress Bar -->
    <div class="qwrap" id="progressBarSection">
      <div class="qbar"
           id="progressBar"
           role="progressbar"
           aria-valuemin="0" aria-valuemax="100" aria-valuenow="0"
           style="--value:0">
        <span class="sr-only" id="progressBarLabel">0% complete</span>
      </div>
      <div class="qticks" aria-hidden="true">
        <span class="t0">0%</span>
        <span class="t25">25%</span>
        <span class="t50">50%</span>
        <span class="t75">75%</span>
        <span class="t100">100%</span>
      </div>
    </div>

  </div>

  <div class="section" id="dataTable">
    <div class="row" style="justify-content: space-between; align-items: baseline;">
      <strong>Readings</strong>
      <span class="muted">Points: <span id="pointsCount">0</span></span>
    </div>
    <div style="overflow: auto; margin-top: 10px; border: 1px solid var(--border); border-radius: 10px;">
      <table id="pointsTable">
        <thead>
          <tr>
            <th>Clock time</th>
            <th>Time (mins)</th>
            <th>Depth to water (mm)</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
    <div class="row" style="gap: 8px; margin-top: 10px; flex-wrap: wrap;">
      <button id="undoButton" class="btn-ghost">Undo last</button>
      <button id="exportButton">Export CSV</button>
    </div>
  </div>

  <!-- Saved Tests / Archive removed: sessions now hold active & archived tests automatically -->
 
  <!-- App base: version + install status (moved from header) -->
  <div style="text-align:center; margin-top:8px;">
    <span class="version-badge" aria-hidden="true" title="App version">v3.1</span>
    <span id="installStatus" class="version-badge" aria-hidden="true" title="Install status">Not installed</span>
  </div>

  <p class="hint">File name includes Location ID &amp; Test Number. Speech input works best in Chrome (desktop/mobile).</p>

  <style>
    /* ---------- Add your Quartile Progress Bar CSS below ---------- */
    .qwrap{ width:min(520px,100%); font: 500 12px/1 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; }

    .qbar{
      --value:64; --h:16px; --track:hsl(0 0% 92%);
      --fill-a:hsl(210 90% 55%); --fill-b:hsl(190 90% 45%);
      --line:hsl(0 0% 0% / .45); --line-w:2px; --r:9999px;

      position: relative;
      height: var(--h);
      border-radius: var(--r);
      background: var(--track);
      box-shadow: inset 0 1px 2px hsl(0 0% 0% / .15);
      overflow: hidden;
    }

    .qbar::after{
      content:""; position:absolute; inset:0; z-index:1;
      transform-origin:left;
      transform: scaleX(calc(clamp(0,var(--value),100) / 100));
      background: linear-gradient(90deg,var(--fill-a),var(--fill-b));
      transition: transform .4s cubic-bezier(.2,.7,.2,1);
    }

    .qbar::before{
      content:""; position:absolute; inset:0; z-index:2; pointer-events:none;
      background:
        linear-gradient(90deg, transparent calc(25% - var(--line-w)/2), var(--line) 0 calc(25% + var(--line-w)/2), transparent 0),
        linear-gradient(90deg, transparent calc(50% - var(--line-w)/2), var(--line) 0 calc(50% + var(--line-w)/2), transparent 0),
        linear-gradient(90deg, transparent calc(75% - var(--line-w)/2), var(--line) 0 calc(75% + var(--line-w)/2), transparent 0);
    }

    .qticks{ position: relative; height: 1.2em; margin-top:6px; color:hsl(0 0% 35%); }
    .qticks span{ position:absolute; top:0; transform:translateX(-50%); text-align:center; }
    .qticks .t0   { left:0; transform:none; text-align:left; }
    .qticks .t25  { left:25%; }
    .qticks .t50  { left:50%; }
    .qticks .t75  { left:75%; }
    .qticks .t100 { right:0; left:auto; transform:none; text-align:right; }

    .sr-only{
      position:absolute; width:1px; height:1px; padding:0; margin:-1px;
      overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0;
    }

    @media (prefers-color-scheme: dark){
      .qbar{ background:hsl(0 0% 18%); box-shadow: inset 0 1px 2px hsl(0 0% 0% / .6); }
      .qbar{ --line: hsl(0 0% 100% / .45); }
      .qticks{ color:hsl(0 0% 75%); }
    }

    /* Tabs UI */
    .tabs { align-items:center; }
    .tab {
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border-radius:10px;
      background:var(--card);
      border:1px solid var(--border);
      color:var(--fg);
      cursor:pointer;
      font-weight:600;
    }
    .tab .close { background:transparent; border:0; color:var(--muted); cursor:pointer; padding:0 4px; }
    .tab.active { outline:3px solid var(--focus-ring); }
    .tab.new { opacity:0.9; }
  </style>

  <script>
    'use strict';

    // Session management for multiple concurrent tests (tabs)
    const sessions = {};      // id -> session object
    let activeSessionId = null;

    function createNewSession(fromData = null) {
      const id = Date.now().toString();
      const base = {
        id,
        locationId: '',
        testNumber: '',
        lengthTop: '',
        lengthBottom: '',
        widthTop: '',
        widthBottom: '',
        depthTested: '',
        depthExcavation: '',
        voidRatio: '',
        strataDescription: '',
        pitDetails: '',
        points: [],
        // Timer state per session (timestamps) - no active interval per session
        startTime: undefined,
        pausedTime: 0,
        pauseStart: undefined,
        isPaused: false,
        testStarted: false,
        hasEverStarted: false,
        currentTestId: null // persisted saved-test id if any
      };
      sessions[id] = fromData ? { ...base, ...fromData, id } : base;
      persistSessions();
      activateSession(id);
      updateTabsUI();
      return id;
    }

    function persistSessions() {
      // store sessions as array to CURRENT_KEY
      localStorage.setItem(CURRENT_KEY, JSON.stringify(Object.values(sessions)));
    }

    function loadPersistedSessions() {
      const arr = JSON.parse(localStorage.getItem(CURRENT_KEY) || 'null');
      if (Array.isArray(arr) && arr.length) {
        arr.forEach(s => sessions[s.id] = s);
        // activate first session by default
        activateSession(arr[0].id);
      } else {
        // create a fresh session if none persisted
        createNewSession();
      }
      updateTabsUI();
    }

    function saveGlobalsToSession(id) {
      if (!id) return;
      const s = sessions[id];
      if (!s) return;
      // copy form fields and globals into session
      s.locationId = document.getElementById('locationId').value;
      s.testNumber = document.getElementById('testNumber').value;
      s.lengthTop = document.getElementById('lengthTop').value;
      s.lengthBottom = document.getElementById('lengthBottom').value;
      s.widthTop = document.getElementById('widthTop').value;
      s.widthBottom = document.getElementById('widthBottom').value;
      s.depthTested = document.getElementById('depthTested').value;
      s.depthExcavation = document.getElementById('depthExcavation').value;
      s.voidRatio = document.getElementById('voidRatio').value || document.getElementById('voidRatioOther').value;
      s.strataDescription = document.getElementById('strataDescription').value;
      s.pitDetails = document.getElementById('pitDetails').value;
      s.points = points.slice();
      // timer globals
      s.startTime = startTime;
      s.pausedTime = pausedTime;
      s.pauseStart = pauseStart;
      s.isPaused = isPaused;
      s.testStarted = testStarted;
      s.hasEverStarted = hasEverStarted;
      s.currentTestId = currentTestId;
      sessions[id] = s;
      persistSessions();
     // ensure the UI (sessions list / tabs summary) reflects updated name immediately
     updateTabsUI();
    }

    function loadSessionToGlobals(id) {
      const s = sessions[id];
      if (!s) return;

      // Ensure points have timestamps (reconstruct from timeMins or clockTime when older saved data doesn't include ts)
      (function ensureSessionPointTimestamps(sess){
        if (!sess || !Array.isArray(sess.points) || sess.points.length === 0) return;
        // if any timestamp already present, nothing to do
        if (sess.points.some(p => p && p.ts)) return;

        const now = Date.now();

        // Try to parse a stored ISO timestamp first, then full date-time, then fallback to HH:MM:SS as today
        function parseClockToTimestamp(raw){
          if (!raw) return null;
          // If it's already an ISO-style stored field (clockISO), parse directly
          if (/^\d{4}-\d{2}-\d{2}T/.test(raw)) {
            const t = Date.parse(raw);
            return isNaN(t) ? null : t;
          }
          // If it contains a date (e.g., "2025-10-01 08:39:36" or "2025-10-01T08:39:36") try Date.parse
          if (/[0-9]{4}-[0-9]{2}-[0-9]{2}/.test(raw)) {
            const t = Date.parse(raw);
            return isNaN(t) ? null : t;
          }
          // Otherwise treat as time-only "HH:MM[:SS]" anchored to today (with wrap to yesterday if in future)
          const parts = raw.split(':').map(n => parseInt(n, 10));
          if (!parts.length || isNaN(parts[0])) return null;
          const d = new Date();
          d.setHours(parts[0] || 0, parts[1] || 0, parts[2] || 0, 0);
          let ts = d.getTime();
          if (ts > now + 60_000) ts -= 24 * 3600 * 1000; // likely wrapped day
          return ts;
        }

        // Collect any parsed clock-time timestamps and any timeMins values
        const clockIsoList = sess.points.map(p => (p && p.clockISO) ? p.clockISO : null).filter(Boolean);
        const clockParsedList = sess.points.map(p => parseClockToTimestamp(p && (p.clockISO || p.clockTime))).filter(Boolean);
        const minsList = sess.points.map(p => parseFloat(p && p.timeMins) || 0);
        const maxMins = minsList.length ? Math.max(...minsList) : 0;

        // Decide anchor: prefer earliest explicit parsed clock, else fallback to now - maxMins
        let startApprox = null;
        if (clockParsedList.length) {
          startApprox = Math.min(...clockParsedList);
        } else {
          startApprox = now - Math.round(maxMins * 60 * 1000);
        }

        // Assign ts for each point:
        sess.points.forEach(p => {
          // prefer explicit ISO if present
          if (p && p.clockISO) {
            const t = Date.parse(p.clockISO);
            p.ts = isNaN(t) ? startApprox : t;
            return;
          }
          // then try parsing clockTime/clock string
          const parsed = parseClockToTimestamp(p && p.clockTime);
          if (parsed) {
            p.ts = parsed;
            return;
          }
          // finally, if timeMins present, position relative to startApprox
          const mins = parseFloat(p && p.timeMins);
          if (!isNaN(mins)) p.ts = startApprox + Math.round(mins * 60 * 1000);
          else p.ts = startApprox;
          // defensive: if computed ts lies in the future, push it back a day
          if (p.ts > now + 60_000) p.ts -= 24 * 3600 * 1000;
        });

        if (!sess.startTime) sess.startTime = startApprox;
        sessions[sess.id] = sess;
        persistSessions();
      })(s);

      // set globals from session
      points = s.points ? s.points.slice() : [];
      startTime = s.startTime;
      pausedTime = s.pausedTime || 0;
      pauseStart = s.pauseStart;
      isPaused = !!s.isPaused;
      testStarted = !!s.testStarted;
      hasEverStarted = !!s.hasEverStarted;
      currentTestId = s.currentTestId || null;

      // populate form fields
      document.getElementById('locationId').value = s.locationId || '';
      document.getElementById('testNumber').value = s.testNumber || '';
      document.getElementById('lengthTop').value = s.lengthTop || '';
      document.getElementById('lengthBottom').value = s.lengthBottom || s.lengthTop || '';
      document.getElementById('widthTop').value = s.widthTop || '';
      document.getElementById('widthBottom').value = s.widthBottom || s.widthTop || '';
      document.getElementById('depthTested').value = s.depthTested || '';
      document.getElementById('depthExcavation').value = s.depthExcavation || '';
      if (s.voidRatio === '1' || s.voidRatio === '0.3') {
        document.getElementById('voidRatio').value = s.voidRatio;
        document.getElementById('voidRatioOther').style.display = 'none';
        document.getElementById('voidRatioOther').value = '';
      } else if (s.voidRatio) {
        document.getElementById('voidRatio').value = '';
        document.getElementById('voidRatioOther').value = s.voidRatio;
        document.getElementById('voidRatioOther').style.display = 'block';
      } else {
        document.getElementById('voidRatio').value = '1';
        document.getElementById('voidRatioOther').style.display = 'none';
        document.getElementById('voidRatioOther').value = '';
      }
      document.getElementById('strataDescription').value = s.strataDescription || '';
      document.getElementById('pitDetails').value = s.pitDetails || '';

      updateTable();
      calculateFalls();
      updateDepthTested();
     // Ensure timer display is consistent with persisted points/state (restore timer first)
     loadTimerState();
     // Now update controls and button text based on the restored timer state
     updateUIState();
     checkStartButton();
    }

    function activateSession(id) {
      if (!id) return;
      if (activeSessionId && activeSessionId !== id) saveGlobalsToSession(activeSessionId);
      activeSessionId = id;
      loadSessionToGlobals(id);
      updateTabsUI();
    }

    function closeSession(id) {
      if (!sessions[id]) return;
      const s = sessions[id];
      const hasData = (s.points && s.points.length > 0) || s.testStarted || s.locationId || s.testNumber;
      const promptMsg = hasData
        ? 'Delete this session and all its data? This cannot be undone.'
        : 'Delete this session?';
      if (!confirm(promptMsg)) return;
      // proceed with deletion
      delete sessions[id];
      persistSessions();
      if (activeSessionId === id) {
        const keys = Object.keys(sessions);
        if (keys.length) activateSession(keys[0]);
        else createNewSession();
      } else {
        updateTabsUI();
      }
    }

    function updateTabsUI() {
      // Prefer rendering into the slide-out sessions panel; fall back to the inline tabsList if present
      const target = document.getElementById('sessionsList') || document.getElementById('tabsList');
      if (!target) return;
      target.innerHTML = '';
      Object.values(sessions).forEach(s => {
        const li = document.createElement('li');
        li.style.display = 'flex';
        li.style.alignItems = 'center';
        li.style.justifyContent = 'space-between';
        li.style.marginBottom = '8px';
        const label = (s.locationId ? s.locationId : 'New') + (s.testNumber ? ` ‚Äî ${s.testNumber}` : '');
        const btnMain = document.createElement('button');
        btnMain.className = 'tab' + (s.id === activeSessionId ? ' active' : '');
        btnMain.type = 'button';
        btnMain.textContent = label;
        btnMain.style.flex = '1';
        btnMain.style.textAlign = 'left';
        // Activate session and close sessions panel (if present) so user can immediately use it
        btnMain.addEventListener('click', () => {
          activateSession(s.id);
          const panel = document.getElementById('sessions');
          if (panel) { panel.classList.remove('open'); panel.setAttribute('aria-hidden','true'); document.body.classList.remove('sessions-open'); }
        });
        const close = document.createElement('button');
        close.type = 'button';
        close.className = 'close';
        close.innerText = '‚úï';
        close.title = 'Close test';
        close.style.marginLeft = '8px';
        close.addEventListener('click', (e) => { e.stopPropagation(); closeSession(s.id); });
        li.appendChild(btnMain);
        li.appendChild(close);
        target.appendChild(li);
      });
      // update a small summary in the tabs bar about active session
      const summary = document.getElementById('tabsSummary');
      if (summary) {
        const s = sessions[activeSessionId];
        summary.textContent = s ? ((s.locationId || 'New') + (s.testNumber ? ` ‚Äî ${s.testNumber}` : '')) : '';
      }
    }

    // Wire new test control ‚Äî create and close sessions panel then open parameters for entry
    document.getElementById('newTestBtn').addEventListener('click', () => {
      createNewSession();

      // close sessions panel
      const sessionsPanel = document.getElementById('sessions');
      if (sessionsPanel) {
        sessionsPanel.classList.remove('open');
        sessionsPanel.setAttribute('aria-hidden', 'true');
        document.body.classList.remove('sessions-open');
      }

      // open parameters panel so user can enter test details immediately
      const params = document.getElementById('parameters');
      if (params) {
        params.classList.add('open');
        params.setAttribute('aria-hidden', 'false');
        document.body.classList.add('panel-open');
      }

      // focus first field and refresh start button state
      const loc = document.getElementById('locationId');
      if (loc) loc.focus();
      checkStartButton();
    });

    // When user navigates away from page, persist current session
    window.addEventListener('beforeunload', ()=> { if (activeSessionId) saveGlobalsToSession(activeSessionId); });

    // Core variables
    let timerInterval;
    let startTime;
    let pausedTime = 0;
    let pauseStart;
    let isPaused = false; // true when timer paused
    let points = [];
    let currentTestId = null;
    let lengthBottomIndependent = false;
    let widthBottomIndependent = false;
    let testStarted = false;
    let hasEverStarted = false; // new flag

    // Local Storage Keys
    const STORAGE_KEY = 'depthLoggerTests';
    const CURRENT_KEY = 'depthLoggerCurrent';

    function filledCell(cell) { return cell !== '' && cell != null; }

    // Save current session state into sessions (auto-save on changes)
    function autoSaveCurrent() {
      if (activeSessionId) saveGlobalsToSession(activeSessionId);
      else persistSessions();
    }
 
    // Get current form data
    function getCurrentData() {
      // Build data from the active session + current DOM
       return {
         id: currentTestId,
         locationId: document.getElementById('locationId').value,
         testNumber: document.getElementById('testNumber').value,
         lengthTop: document.getElementById('lengthTop').value,
         lengthBottom: document.getElementById('lengthBottom').value,
         widthTop: document.getElementById('widthTop').value,
         widthBottom: document.getElementById('widthBottom').value,
         depthTested: document.getElementById('depthTested').value,
         depthExcavation: document.getElementById('depthExcavation').value,
         voidRatio: document.getElementById('voidRatio').value || document.getElementById('voidRatioOther').value,
         strataDescription: document.getElementById('strataDescription').value,
         pitDetails: document.getElementById('pitDetails').value,
        points: points,
        testStarted: testStarted
       };
     }

    // Set form data
    function setCurrentData(data) {
      // Keep original behavior ‚Äî simply fill DOM from provided object
      document.getElementById('locationId').value = data.locationId || '';
      document.getElementById('testNumber').value = data.testNumber || '';
      document.getElementById('lengthTop').value = data.lengthTop || '';
      document.getElementById('lengthBottom').value = data.lengthBottom || data.lengthTop || '';
      document.getElementById('widthTop').value = data.widthTop || '';
      document.getElementById('widthBottom').value = data.widthBottom || data.widthTop || '';
      document.getElementById('depthTested').value = data.depthTested || '';
      document.getElementById('depthExcavation').value = data.depthExcavation || '';
      if (data.voidRatio === '1' || data.voidRatio === '0.3') {
        document.getElementById('voidRatio').value = data.voidRatio;
        document.getElementById('voidRatioOther').style.display = 'none';
      } else if (data.voidRatio) {
        document.getElementById('voidRatio').value = '';
        document.getElementById('voidRatioOther').value = data.voidRatio;
        document.getElementById('voidRatioOther').style.display = 'block';
      } else {
        document.getElementById('voidRatio').value = '1';
        document.getElementById('voidRatioOther').style.display = 'none';
        document.getElementById('voidRatioOther').value = '';
      }
      document.getElementById('strataDescription').value = data.strataDescription || '';
      document.getElementById('pitDetails').value = data.pitDetails || '';
      points = data.points || [];
      testStarted = !!(data.testStarted || (points && points.length > 0));
      hasEverStarted = testStarted;
    }

    // Reset form
    function resetForm() {
      // For multi-session: reset the active session only (or create a new one)
      if (activeSessionId) {
        sessions[activeSessionId] = {
          id: activeSessionId,
          locationId: '',
          testNumber: '',
          lengthTop: '',
          lengthBottom: '',
          widthTop: '',
          widthBottom: '',
          depthTested: '',
          depthExcavation: '',
          voidRatio: '',
          strataDescription: '',
          pitDetails: '',
          points: [],
          startTime: undefined,
          pausedTime: 0,
          pauseStart: undefined,
          isPaused: false,
          testStarted: false,
          hasEverStarted: false,
          currentTestId: null
        };
        persistSessions();
        loadSessionToGlobals(activeSessionId);
      } else {
        // fallback single-session behavior
        currentTestId = null;
        points = [];
        lengthBottomIndependent = false;
        widthBottomIndependent = false;
        testStarted = false;
        setCurrentData({});
        document.getElementById('lengthBottom').value = '';
        document.getElementById('widthBottom').value = '';
        document.getElementById('depthTested').value = '';
        updateTable();
        calculateFalls();
        localStorage.removeItem(CURRENT_KEY);
      }

      // Reset timer
      document.getElementById('timer').textContent = '00:00:00';
      startTime = undefined;
      pausedTime = 0;
      pauseStart = undefined;
      isPaused = false;
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = null;
      updateUIState();
      checkStartButton();
    }

    // Update UI state
    function updateUIState() {
      document.getElementById('locationId').disabled = testStarted;
      document.getElementById('testNumber').disabled = testStarted;
      document.getElementById('stopTimer').disabled = points.length === 0;
    }

    // Check Start button state
    function checkStartButton() {
      const locationId = document.getElementById('locationId').value.trim();
      const testNumber = document.getElementById('testNumber').value.trim();
      const lengthTop = document.getElementById('lengthTop').value.trim();
      const widthTop = document.getElementById('widthTop').value.trim();
      const depthExcavation = document.getElementById('depthExcavation').value.trim();
      const btn = document.getElementById('startPauseBtn');
      if (!testStarted) {
        btn.disabled = !locationId || !testNumber || !lengthTop || !widthTop || !depthExcavation;
        btn.textContent = 'Start';
      } else {
        btn.disabled = false; // allow pausing/resuming once started
        // When paused show 'Resume', otherwise 'Pause'
        btn.textContent = isPaused ? 'Resume' : 'Pause';
      }
    }

    // Timer functions
    function updateTimer() {
      // Prefer deriving elapsed from the timestamp of the oldest recorded reading (most robust)
      const now = isPaused ? pauseStart : Date.now();
      let elapsed = 0;
      if (points.length > 0) {
        const tsList = points.map(p => Number(p.ts || 0)).filter(v => v > 0);
        if (tsList.length) {
          const firstTs = Math.min(...tsList);
          elapsed = now - firstTs - (pausedTime || 0);
        } else if (typeof startTime !== 'undefined' && startTime) {
          elapsed = now - startTime - (pausedTime || 0);
        } else {
          elapsed = 0;
        }
      } else if (typeof startTime !== 'undefined' && startTime) {
        elapsed = now - startTime - (pausedTime || 0);
      } else {
        elapsed = 0;
      }
      const seconds = Math.round(elapsed / 1000);
      const h = Math.floor(seconds / 3600).toString().padStart(2, '0');
      const m = Math.floor((seconds % 3600) / 60).toString().padStart(2, '0');
      const s = (seconds % 60).toString().padStart(2, '0');
      document.getElementById('timer').textContent = `${h}:${m}:${s}`;
    }

    // Single Start/Pause toggle
    document.getElementById('startPauseBtn').addEventListener('click', () => {
      // Use session flags to control timer; button label is driven by checkStartButton()
      if (!hasEverStarted) {
        // FIRST press -> Start the timer
        startTime = Date.now();
        pausedTime = 0;
        isPaused = false;
        testStarted = true;
        hasEverStarted = true;
        if (timerInterval) clearInterval(timerInterval);
        timerInterval = setInterval(updateTimer, 1000);
        // update display immediately so user doesn't wait up to 1s
        updateTimer();
      } else if (isPaused) {
        // Resume: prefer recalculating from the earliest recorded datapoint (like loadTimerState)
        const now = Date.now();
        if (points.length > 0) {
          const tsList = points.map(p => Number(p.ts || 0)).filter(v => v > 0);
          if (tsList.length) {
            // Anchor to the oldest reading so elapsed = now - firstTs
            const firstTs = Math.min(...tsList);
            // Clear any paused offset so clock reflects time since earliest point
            pausedTime = 0;
            pauseStart = undefined;
            isPaused = false;
            // ensure interval restarts cleanly and update immediately
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(updateTimer, 1000);
            updateTimer();
          } else {
            // No reliable point timestamps ‚Äî fallback to accumulating paused duration
            const resumedAt = now;
            const added = resumedAt - (pauseStart || resumedAt);
            pausedTime = (pausedTime || 0) + added;
            pauseStart = undefined;
            isPaused = false;
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(updateTimer, 1000);
            updateTimer();
          }
        } else {
          // No points: normal resume behavior
          const resumedAt = now;
          const added = resumedAt - (pauseStart || resumedAt);
          pausedTime = (pausedTime || 0) + added;
          pauseStart = undefined;
          isPaused = false;
          if (timerInterval) clearInterval(timerInterval);
          timerInterval = setInterval(updateTimer, 1000);
          updateTimer();
        }
      } else {
        // Pause
        if (timerInterval) clearInterval(timerInterval);
        pauseStart = Date.now();
        isPaused = true;
        // show frozen time immediately
        updateTimer();
      }
      updateUIState();
      checkStartButton(); // centralised label control
      updateProgressUI();
    });
    
    // Stop
    document.getElementById('stopTimer').addEventListener('click', () => {
      if (!confirm('Confirm end of test? This will stop the timer and auto-export the CSV.')) return;
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = null;
      pausedTime = 0;
      isPaused = false;
      startTime = undefined;
      pauseStart = undefined;
      document.getElementById('timer').textContent = '00:00:00';
      exportCSV();
      testStarted = false;
      hasEverStarted = false; // reset so next press behaves like a fresh Start
      checkStartButton();
      updateUIState();
    });

    // Load timer state to paused at latest time or derive from first reading
    function loadTimerState() {
      const btn = document.getElementById('startPauseBtn');

      // If we have recorded points we derive the timer from the earliest reading timestamp.
      if (points.length > 0) {
        const tsList = points.map(p => Number(p.ts || 0)).filter(v => v > 0);
        const hasTs = tsList.length > 0;
        const firstTs = hasTs ? Math.min(...tsList) : null;
        if (!hasTs) {
          // fall back to previous behaviour if no timestamps available
          if (!(typeof startTime !== 'undefined' && startTime)) {
            // no reliable timing info
            document.getElementById('timer').textContent = '00:00:00';
            if (btn) btn.textContent = 'Start';
            // ensure related UI matches restored state
            updateUIState();
            checkStartButton();
            return;
          }
        }
         // pausedTime already persisted per-session; if session marked paused, keep pauseStart
         testStarted = true;
         hasEverStarted = true;
         // if paused, show Resume; if running, start interval to update live
         if (isPaused) {
           // keep timer stopped but show last elapsed
           pauseStart = pauseStart || Date.now();
           if (btn) btn.textContent = 'Resume';
           updateTimer();
           if (timerInterval) { clearInterval(timerInterval); timerInterval = null; }
         } else {
           // running: ensure timer interval is active to update display
           if (timerInterval) clearInterval(timerInterval);
           timerInterval = setInterval(updateTimer, 1000);
           if (btn) btn.textContent = 'Pause';
           updateTimer();
         }
         // ensure related controls reflect restored timer state
         updateUIState();
         checkStartButton();
         return;
       }

      // Fallback: no points ‚Äî revert to previous behaviour using startTime if present
      if (points.length === 0 && typeof startTime !== 'undefined' && startTime) {
        testStarted = true;
        hasEverStarted = true;
        if (isPaused) {
          if (btn) btn.textContent = 'Resume';
          updateTimer();
          if (timerInterval) { clearInterval(timerInterval); timerInterval = null; }
        } else {
          if (timerInterval) clearInterval(timerInterval);
          timerInterval = setInterval(updateTimer, 1000);
          if (btn) btn.textContent = 'Pause';
          updateTimer();
        }
        // update related controls
        updateUIState();
        checkStartButton();
        return;
      }

      // default reset
      document.getElementById('timer').textContent = '00:00:00';
      startTime = undefined;
      pausedTime = 0;
      pauseStart = undefined;
      isPaused = false;
      testStarted = false;
      if (btn) btn.textContent = 'Start';
      if (timerInterval) { clearInterval(timerInterval); timerInterval = null; }

      // Ensure UI controls match reset state
      updateUIState();
      checkStartButton();
    }

    // Record point
    function recordPoint() {
      const depthEl = document.getElementById('depthInput');
      const depth = parseFloat(depthEl.value);
      const depthErrorEl = document.getElementById('depthError');
      // clear previous error
      if (depthErrorEl) depthErrorEl.style.display = 'none';
      if (isNaN(depth)) return;
      // Validate against excavation depth
      const excavation = parseFloat(document.getElementById('depthExcavation').value);
      if (isFinite(excavation) && depth > excavation) {
        if (depthErrorEl) {
          depthErrorEl.textContent = 'Depth cannot be greater than excavation depth. Please re-measure.';
          depthErrorEl.style.display = 'block';
        } else {
          alert('Depth cannot be greater than excavation depth. Please re-measure.');
        }
        depthEl.focus();
        return;
      }
      const nowMs = Date.now();
      const clockTime = new Date(nowMs).toLocaleTimeString(); // for display (local)
      const clockISO = new Date(nowMs).toISOString();        // full ISO timestamp (UTC)
 
      // If this is the first recorded reading, mark session-first timestamp and ensure timer runs.
      if (points.length === 0) {
        // mark first point timestamp and ensure timer flags
        startTime = startTime || nowMs;
        pausedTime = pausedTime || 0;
        isPaused = false;
        testStarted = true;
        hasEverStarted = true;
        // ensure interval runs
        if (timerInterval) clearInterval(timerInterval);
        timerInterval = setInterval(updateTimer, 1000);
        // update display immediately so user sees correct elapsed anchored to first reading
        updateTimer();
        // ensure the start/pause button reflects running state immediately
        checkStartButton();
        updateUIState();
      }
 
      // compute elapsed from first reading timestamp if present
      const firstTs = (points.length > 0 && points[0].ts) ? Number(points[0].ts) : nowMs;
      const nowForElapsed = isPaused ? (pauseStart || nowMs) : nowMs;
      const elapsedMins = ((nowForElapsed - firstTs - (pausedTime || 0)) / 1000 / 60);
      const timeMins = Math.max(0, elapsedMins).toFixed(2);
 
      // store timestamp + ISO on each point so timers can be reconstructed reliably across restarts (includes date)
      points.push({ clockTime, clockISO, timeMins, depth, ts: nowMs });
       // Always update calculated fields and progress after each new point
       updateDepthTested();
       updateTable();
       calculateFalls();
       document.getElementById('depthInput').value = '';
       autoSaveCurrent();
       updateUIState();
       // ensure the button label and timer reflect the new running state immediately
       checkStartButton();
       updateProgressUI(); // defensive: ensure bar syncs immediately
    }

    document.getElementById('recordButton')?.addEventListener('click', recordPoint);
    document.getElementById('depthInput').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') recordPoint();
    });

    // Update table (latest at top)
    function updateTable() {
      const tbody = document.getElementById('pointsTable').querySelector('tbody');
      tbody.innerHTML = '';
      points.slice().reverse().forEach(point => {
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${point.clockTime}</td><td>${point.timeMins}</td><td>${point.depth}</td>`;
        tbody.appendChild(tr);
      });
      document.getElementById('pointsCount').textContent = points.length;
    }

    // Calculate 25% and 75% falls
    function calculateFalls() {
      if (points.length < 1) {
        document.getElementById('fall25').textContent = '‚Äî';
        document.getElementById('fall75').textContent = '‚Äî';
        return;
      }

      // Use the initial DTW reading and the excavation depth to compute the head-of-water
      const initialDepth = Number(points[0].depth);
      const excavation = parseFloat(document.getElementById('depthExcavation').value);

      // If excavation or initial depth are invalid, or excavation is not deeper than initial, we cannot compute falls
      if (!isFinite(initialDepth) || !isFinite(excavation) || excavation <= initialDepth) {
        document.getElementById('fall25').textContent = '‚Äî';
        document.getElementById('fall75').textContent = '‚Äî';
        return;
      }

      const head = excavation - initialDepth; // head of water being tested
      const fall25 = head * 0.25;
      const fall75 = head * 0.75;
      document.getElementById('fall25').textContent = fall25.toFixed(2);
      document.getElementById('fall75').textContent = fall75.toFixed(2);
    }

    // Update Depth Tested (shows current tested depth)
    function updateDepthTested() {
      const exc = parseFloat(document.getElementById('depthExcavation').value) || 0;
      if (points.length > 0) {
        // Current depth is the latest reading
        const currentDepth = points[points.length - 1].depth;
        document.getElementById('depthTested').value = exc - currentDepth;
      } else {
        document.getElementById('depthTested').value = '';
      }
      updateProgressUI();
    }

    // Progress UI
    function updateProgressUI() {
      const qbar = document.getElementById('progressBar');
      const sr = document.getElementById('progressBarLabel'); // matches your HTML id
      const dtLive = document.getElementById('depthTestedLive');
      if (!qbar) return;

      // Live mirror for Depth tested field (optional, if you add #depthTestedLive somewhere)
      if (dtLive) dtLive.textContent = document.getElementById('depthTested').value || '‚Äî';

      let percent = 0;
      if (points.length > 0) {
        const initial = Number(points[0].depth); // first DTW reading
        const current = Number(points[points.length - 1].depth);
        const excavation = parseFloat(document.getElementById('depthExcavation').value);
        const depthTested = (isFinite(excavation) ? excavation : 0) - initial; // head of water
        if (depthTested > 0 && !isNaN(current)) {
          // Progress defined by how much DTW has increased toward excavation depth.
          // Example: exc=1500, initial=500, current=750 => (750-500)/1000 = 25%
          const advanced = Math.max(0, current - initial);
          percent = Math.round(Math.min(100, Math.max(0, (advanced / depthTested) * 100)));
        }
      }
      qbar.style.setProperty('--value', String(percent));
      qbar.setAttribute('aria-valuenow', String(percent));
      if (sr) sr.textContent = `${percent}% complete`;
    }

    // Also update progress bar when excavation depth changes
    document.getElementById('depthExcavation').addEventListener('input', () => {
      updateDepthTested();
      autoSaveCurrent();
      checkStartButton();
    });

    // Undo last
    document.getElementById('undoButton').addEventListener('click', () => {
      if (points.length === 0) return;
      points.pop();
      updateTable();
      calculateFalls();
      updateDepthTested();
      autoSaveCurrent();
      updateUIState();
    });

    // CSV builder (pure) ‚Äî used by exportCSV and tests
    function buildCSVString(data, pts) {
      const rows = [
        'Test Parameters',
        `Location ID,${data.locationId || ''}`,
        `Test Number,${data.testNumber || ''}`,
        `Length at Top (mm),${data.lengthTop || ''}`,
        `Length at Bottom (mm),${data.lengthBottom || data.lengthTop || ''}`,
        `Width at Top (mm),${data.widthTop || ''}`,
        `Width at Bottom (mm),${data.widthBottom || data.widthTop || ''}`,
        `Depth Tested (mm),${data.depthTested || ''}`,
        `Depth of Excavation (mm),${data.depthExcavation || ''}`,
        `Void Ratio,${data.voidRatio || ''}`,
        `Strata Description,${(data.strataDescription || '').replace(/\n/g,' ')}`,
        `Pit Details,${(data.pitDetails || '').replace(/\n/g,' ')}`,
        '',
        'Data',
        // UK-format date column inserted between Clock time and Time (mins)
        'Clock time,Date (UK),Time (mins),Depth to water (mm)'
      ];
      pts.forEach(p => {
        // prefer explicit ISO or ts; fall back to empty
        const ts = p.clockISO ? Date.parse(p.clockISO) : (p.ts ? Number(p.ts) : NaN);
        const dateUk = !isNaN(ts)
          ? new Date(ts).toLocaleDateString('en-GB')
          : '';
        rows.push(`${p.clockTime},${dateUk},${p.timeMins},${p.depth}`);
      });
      return rows.join('\n');
    }

    // Export CSV (uses builder)
    function exportCSV() {
      const data = getCurrentData();
      const csv = buildCSVString(data, points);

      // sanitize parts for filenames
      const locationId = (data.locationId || 'unknown').replace(/[^\w.\-]/g, '_');
      const testNumber = (data.testNumber || 'unknown').replace(/[^\w.\-]/g, '_');

      // YYYYMMDD_HHMMSS timestamp (local)
      const now = new Date();
      const pad = (v) => String(v).padStart(2, '0');
      const ts = `${now.getFullYear()}${pad(now.getMonth()+1)}${pad(now.getDate())}_${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}`;

      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${locationId}_${testNumber}_${ts}.csv`;
      a.click();
      URL.revokeObjectURL(url);
    }

    document.getElementById('exportButton').addEventListener('click', exportCSV);

    // Clear current
    document.getElementById('clearCurrent').addEventListener('click', () => {
      if (confirm('Clear current test data?')) resetForm();
    });

    // Void ratio other
    document.getElementById('voidRatio').addEventListener('change', (e) => {
      const other = document.getElementById('voidRatioOther');
      if (e.target.value === '') {
        other.style.display = 'block';
      } else {
        other.style.display = 'none';
        other.value = '';
      }
      autoSaveCurrent();
    });

    // Bottom tracking top
    function trackBottom(idTop, idBottom, independentFlag) {
      const top = document.getElementById(idTop);
      const bottom = document.getElementById(idBottom);
      top.addEventListener('input', () => {
        if (!window[independentFlag]) bottom.value = top.value;
        autoSaveCurrent();
        checkStartButton();
      });
      bottom.addEventListener('input', () => {
        window[independentFlag] = true;
        autoSaveCurrent();
      });
    }
    trackBottom('lengthTop', 'lengthBottom', 'lengthBottomIndependent');
    trackBottom('widthTop', 'widthBottom', 'widthBottomIndependent');

    // Slide-out panel (uses transform so it fully disappears when closed)
    document.getElementById('parametersToggle').addEventListener('click', () => {
      document.getElementById('parameters').classList.add('open');
      document.body.classList.add('panel-open');
    });
    document.getElementById('parametersClose').addEventListener('click', () => {
      document.getElementById('parameters').classList.remove('open');
      document.body.classList.remove('panel-open');
    });

    // Sessions (left panel) controls
    document.getElementById('sessionsToggle')?.addEventListener('click', () => {
      const panel = document.getElementById('sessions');
      panel.classList.add('open');
      panel.setAttribute('aria-hidden', 'false');
      document.body.classList.add('sessions-open');
    });
    document.getElementById('sessionsClose')?.addEventListener('click', () => {
      const panel = document.getElementById('sessions');
      panel.classList.remove('open');
      panel.setAttribute('aria-hidden', 'true');
      document.body.classList.remove('sessions-open');
    });

    // Speech recognition
    const speechButton = document.getElementById('speechButton');
    if ('SpeechRecognition' in window || 'webkitSpeechRecognition' in window) {
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      speechButton.addEventListener('click', () => {
        const recognition = new SpeechRecognition();
        recognition.onresult = (event) => {
          const transcript = event.results[0][0].transcript;
          document.getElementById('depthInput').value = parseFloat(transcript);
          recordPoint();
        };
        recognition.start();
      });
    } else {
      speechButton.disabled = true;
      speechButton.title = 'Speech recognition not supported';
    }

    // Saved Tests UI removed; saving now occurs automatically into sessions (autoSaveCurrent / archive on stop)
 
    // ------- Theme persistence (export applyTheme for tests) -------
    (function(){
      const themeToggle = document.getElementById('themeToggle');
      const LSKEY = 'dtw.theme';
      function applyTheme(mode){
        if (mode === 'light') {
          document.body.classList.add('theme-light');
        } else {
          document.body.classList.remove('theme-light');
        }
      }
      function updateToggleVisual(mode){
        if (!themeToggle) return;
        const isLight = mode === 'light';
        themeToggle.setAttribute('aria-pressed', String(isLight));
        themeToggle.classList.toggle('is-light', isLight);
        // icon-only button: set its text to the proper glyph
        themeToggle.textContent = isLight ? '‚òÄÔ∏è' : 'üåô';
        themeToggle.setAttribute('aria-label', isLight ? 'Light theme active. Click to switch to dark.' : 'Dark theme active. Click to switch to light.');
      }
      // expose for tests
      window.__applyTheme = applyTheme;

      const saved = localStorage.getItem(LSKEY);
      const initial = (saved === 'light' ? 'light' : 'dark');
      applyTheme(initial);
      updateToggleVisual(initial);

      if (themeToggle){
        themeToggle.addEventListener('click', ()=>{
          const currentMode = document.body.classList.contains('theme-light') ? 'light' : 'dark';
          const next = currentMode === 'light' ? 'dark' : 'light';
          localStorage.setItem(LSKEY, next);
          applyTheme(next);
          updateToggleVisual(next);
        });
      }
    })();

    // Load current on init
    (function init(){
      // Load persisted sessions (if any) and initialize tabs
      loadPersistedSessions();

      // Defensive re-check after restore: ensure timer and button reflect restored session state.
      // Small timeout avoids ordering/race issues where other init logic updates DOM afterwards.
      setTimeout(() => {
        if (activeSessionId) {
          // reload session state to globals (idempotent) then ensure timer UI is correct
          loadSessionToGlobals(activeSessionId);
        } else {
          loadTimerState();
        }
        updateUIState();
        checkStartButton();
      }, 50);
 
      // Auto-save and check start button on parameter changes
      const params = document.querySelectorAll('#parameters input, #parameters select, #parameters textarea');
      params.forEach(el => el.addEventListener('input', () => {
        autoSaveCurrent();
        checkStartButton();
      }));

      // Update depth tested on excavation change
      document.getElementById('depthExcavation').addEventListener('input', () => {
        updateDepthTested();
        autoSaveCurrent();
        checkStartButton();
      });

      // PWA Service Worker
      if ('serviceWorker' in navigator) {
        const swPath = './sw.js?v=3.1';
        window.addEventListener('load', () => {
          navigator.serviceWorker.register(swPath, { scope: './' })
            .then(registration => { console.log('Service Worker registered with scope:', registration.scope); })
            .catch(error => { console.error('Service Worker registration failed:', error.message, 'Path tried:', swPath); });
        });
      }

      // Install status indicator (shows "Installed ‚úÖ" or "Not installed")
      const installStatusEl = document.getElementById('installStatus');
      if (installStatusEl) {
        const isStandalone = (window.matchMedia && window.matchMedia('(display-mode: standalone)').matches) || window.navigator.standalone;
        installStatusEl.textContent = isStandalone ? 'Installed ‚úÖ' : 'Not installed';
      }
    })();

    // Ensure tabs UI initial render (in case sessions were created during init)
    updateTabsUI();

    // ---------------- Self-tests (non-intrusive, console only) ----------------
    (function selfTests(){
      try {
        console.group('[DTW Logger] Self-tests');
        let passed = 0, failed = 0;

        // Test 1: CSV builder should include headers and data rows
        const sampleData = {
          locationId: 'TP03', testNumber: 'Test 1', lengthTop: '2000', lengthBottom: '2000', widthTop: '600', widthBottom: '600', depthTested: '250', depthExcavation: '2000', voidRatio: '1', strataDescription: 'Sand over clay', pitDetails: 'Benched'
        };
        const sampleTs = new Date(2025, 11, 14, 11, 48, 35).getTime();
        const sampleDate = new Date(sampleTs).toLocaleDateString('en-GB');
        const samplePts = [{clockTime:'11:48:35', timeMins:'0.00', depth:100, ts: sampleTs}];
        const csv = buildCSVString(sampleData, samplePts);
        console.assert(csv.includes('Test Parameters'), 'CSV missing header section');
        console.assert(csv.includes('Clock time,Date (UK),Time (mins),Depth to water (mm)'), 'CSV missing column header');
        console.assert(csv.includes(`11:48:35,${sampleDate},0.00,100`), 'CSV missing data row');
        passed += 3;

        // Test 2: Theme toggling adds/removes class
        window.__applyTheme('light');
        console.assert(document.body.classList.contains('theme-light'), 'Light theme not applied');
        window.__applyTheme('dark');
        console.assert(!document.body.classList.contains('theme-light'), 'Dark theme not applied');
        passed += 2;

        // Test 3: Parameters panel class toggling
        const panel = document.getElementById('parameters');
        panel.classList.add('open'); document.body.classList.add('panel-open');
        console.assert(panel.classList.contains('open'), 'Panel did not open');
        panel.classList.remove('open'); document.body.classList.remove('panel-open');
        console.assert(!panel.classList.contains('open'), 'Panel did not close');
        passed += 2;

        // Test 4: Start button enablement logic
        const ids = ['locationId','testNumber','lengthTop','widthTop','depthExcavation'];
        const prev = Object.fromEntries(ids.map(id=>[id, document.getElementById(id).value]));
        document.getElementById('locationId').value = 'TP03';
        document.getElementById('testNumber').value = 'Test 1';
        document.getElementById('lengthTop').value = '2000';
        document.getElementById('widthTop').value = '600';
        document.getElementById('depthExcavation').value = '2000';
        testStarted = false; isPaused = false; startTime = undefined; pausedTime = 0;
        checkStartButton();


       

        console.assert(!document.getElementById('startPauseBtn').disabled, 'Start button should be enabled when required fields set');
        // restore
        ids.forEach(id=>document.getElementById(id).value = prev[id] || '');
        checkStartButton();
        passed += 1;

        // Test 5: Saved tests label formatting (does not persist)
        const prevStore = localStorage.getItem(STORAGE_KEY);
        const fake = [{ id: '1730000000000', locationId: 'ID-99', testNumber: 'Test Z', savedAt: new Date('2025-01-01T12:00:00Z').toISOString() }];
        localStorage.setItem(STORAGE_KEY, JSON.stringify(fake));
        loadSavedTests();
        const listText = document.getElementById('testsList').textContent;
        console.assert(listText.includes('ID-99 - Test Z'), 'Saved tests label not formatted correctly');
               // restore store
        if (prevStore === null) localStorage.removeItem(STORAGE_KEY); else localStorage.setItem(STORAGE_KEY, prevStore);
        loadSavedTests();
        passed += 1;

        console.log(`Self-tests passed: ${passed}, failed: ${failed}`);
        console.groupEnd();
           } catch (err) {
        console.error('Self-tests error:', err);
      }
    })();
  </script>

  <style>
    /* Prevent pull-to-refresh on mobile (borrowed from Nopull Stopwatch) */
    html, body { overscroll-behavior-y: none; }
    @media (pointer: coarse) {
      @supports (-webkit-backdrop-filter: blur(1px)) and (overscroll-behavior-y: none) {
        html { min-height: 100.3%; }
      }
    }
    @media (pointer: coarse) {
      @supports (-webkit-backdrop-filter: blur(1px)) and (not (overscroll-behavior-y: none)) {
        html { height: 100%; overflow: hidden; }
        body { margin: 0; max-height: 100%; overflow: auto; -webkit-overflow-scrolling: touch; }
      }
    }

    /* Theme toggle styles (icon-only variant) */
    .theme-toggle{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding:8px;
      width:40px;
      height:40px;
      border-radius:10px;
      border:1px solid var(--border);
      background:color-mix(in srgb, var(--card) 88%, transparent);
      color:var(--fg);
      cursor:pointer;
      font-weight:700;
      font-size:18px;
      line-height:1;
    }
    .theme-toggle:focus{ outline:3px solid var(--focus-ring); outline-offset:3px; }
    .theme-toggle.is-light{ background: linear-gradient(90deg, #fff 0%, #f2f6ff 100%); color:var(--fg); border-color:var(--border); }
    @media (prefers-color-scheme: dark){
      .theme-toggle{ background: color-mix(in srgb, var(--card) 92%, #000 8%); }
    }
    .theme-toggle { width:36px; height:36px; padding:6px; font-size:16px; }

    /* Version / install badge style ‚Äî moved here from leaked fragment */
    .version-badge{
      display:inline-block;
      font-weight:700;
      color: var(--muted);
      border: 1px solid var(--border);
      background: color-mix(in srgb, var(--card) 88%, transparent);
      border-radius: 999px;
      padding: 2px 6px;
      font-size: 0.75rem;
    }
  </style>
</body>
</html>
